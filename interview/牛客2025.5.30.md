
每个`Thread`对象内部都有一个`ThreadLocalMap`类型的对象。

- **Key**: `ThreadLocal`对象本身。这是一个**弱引用**，目的是为了防止内存泄漏。
    - **注意**: 即便使用了弱引用，如果线程长期存活（例如在线程池中），`ThreadLocal`对象占用的内存也不会被回收。因此，在不需要时应**手动释放**（调用`remove()`方法）。
- **Value**: 我们想要存储的线程局部变量的副本。

---

## 内存泄漏与栈溢出

### 内存泄漏 (Memory Leak)

**内存泄漏**指的是程序中已分配的内存，由于某种原因在不再需要时没有被正确释放或回收，导致这块内存无法被后续的程序运行分配给新的需求。长此以往，可用的系统内存会越来越少，最终可能导致程序变慢或崩溃。

**常见原因**:

- 资源未关闭（如文件流、数据库连接）。
- `ThreadLocal`使用不当且未手动`remove()`。

### 栈溢出 (Stack Overflow)

**栈溢出**指的是函数调用栈过深，导致分配给线程的栈空间被耗尽。这是**栈空间不足**，而非堆空间不足。

**常见原因**:

- 无限递归或过深的递归调用。

---

## Redisson主从不一致的解决方法

1. **利用Redis的`WAIT`命令**: 可以使用Redis本身的`WAIT`命令来保证写操作同步到指定数量的从节点后才返回。客户端会阻塞，直到收到足够数量从节点的成功回复，从而在一定程度上保证主从数据的一致性。
2. **使用`ReadMode.MASTER`**: 可以设置Redisson的读取模式为`ReadMode.MASTER`，这样所有的读操作和写操作都在主节点上进行。从节点仅作为数据冗余备份。
    - **影响**: 这种做法会牺牲CAP理论中的A (Availability) 或 P (Partition Tolerance) 的一部分，以增强C (Consistency)。这会影响整体吞吐量，系统不再是典型的读写分离架构。

---

## Redis存Session的实现方式

**基本思路**:

- 使用Session ID作为Key (e.g., `session:{sessionId}`).
- Session数据作为Value，通常使用Redis Hash结构进行存储。

**过期时间策略**:

- 整个Session Key的过期时间代表Session的整体有效时间。
- **滑动窗口式过期**: 每次用户活动时，重新对Session Key设置过期时间（`EXPIRE`命令），重置其存活时间。
- 用户登出时，显式删除对应的Session Key (`DEL session:{sessionId}`).

### 对比直接使用一个JSON字符串存储的优劣

- **优势 (使用Redis Hash)**:
    - **访问更细粒度**: 可用`HGET`/`HSET`操作单个字段，无需序列化/反序列化整个对象，减少网络IO。
    - 并发修改不同字段时，Hash能天然避免覆盖。
- **劣势 (使用Redis Hash)**:
    - 修改多个字段可能需要多次`HSET`，非原子性（除非用Lua脚本或事务）。
    - 若一次请求需大量字段，多次`HGET`可能不如一次`GET`整个JSON。
    - JSON字符串的`SET`操作是原子性的。

### 高并发下的注意事项及崩溃处理

- **并发读写/刷新过期时间**:
    - **问题**: 可能发生数据覆盖。
    - **解决方案**: 使用Lua脚本（保证原子性）或乐观锁机制。
- **应用服务器在更新Session数据后、执行`EXPIRE`前崩溃**:
    - **发生情况**: Session数据已更新，但过期时间未刷新，可能导致Session提前过期。
    - **缓解办法**:
        - 使用原子命令如`SETEX key seconds value`（设置值和过期时间）。
        - 使用Lua脚本将数据更新和`EXPIRE`操作封装在一起执行，保证原子性。对于仅续期，`EXPIRE`比`SETEX`开销小；对于原子更新并续期，Lua是最佳选择。

---

## 进程和线程的区别，在系统调度上的差异

- **进程 (Process)**: 操作系统进行**资源分配和拥有的基本单位**。每个进程有独立的内存空间。
- **线程 (Thread)**: 操作系统进行**调度和分派的基本单位**。线程共享所属进程的内存空间。

**系统调度差异**:

- **调度单位**: **线程**。
- **切换开销**:
    - **线程切换**: 开销非常小（共享内存空间）。
    - **进程切换**: 开销大得多（需切换内存地址空间等）。

---

## 死锁的四个必要条件，以及如何避免死锁

**死锁的四个必要条件**:

1. **互斥条件 (Mutual Exclusion)**
2. **请求与保持条件 (Hold and Wait)**
3. **不可剥夺条件 (No Preemption)**
4. **循环等待条件 (Circular Wait)**

**如何避免死锁 (破坏上述条件)**:

1. **尽量使资源共享** (破坏互斥)。
2. **一次性申请所有资源** (破坏请求与保持)。
3. **允许系统强行剥夺资源** (破坏不可剥夺)。
4. **对资源进行线性排序，按序申请** (破坏循环等待，最常用)。

---

## Class类加载过程

1. **加载 (Loading)**:
    - 查找并获取类的二进制字节流。
    - 将字节流代表的静态存储结构转化为方法区的运行时数据结构。
    - 在内存中生成一个代表这个类的`java.lang.Class`对象。
2. **链接 (Linking)**:
    - **a. 验证 (Verification)**: 确保符合JVM规范，不危害安全。
    - **b. 准备 (Preparation)**: 为类静态变量分配内存并设置初始零值。
    - **c. 解析 (Resolution)**: 将常量池内的符号引用替换为直接引用。
3. **初始化 (Initialization)**:
    - 执行类的初始化方法`<clinit>()`（由编译器收集静态变量赋值和静态块产生）。

---

## ConcurrentHashMap的线程安全及策略进化

- **`HashMap`**: 非线程安全。
    
- **`Hashtable`**: 早期方案，方法上加`synchronized`锁整个对象，并发性能差。
    
- **`ConcurrentHashMap` JDK 1.7 (分段锁 Segment)**:
    
    - 内部由`Segment`数组构成，每个`Segment`有自己的锁。`put`操作锁对应`Segment`。
    - `get`操作不加锁，用`volatile`保证可见性。
    - **缺点**: `Segment`数量固定，哈希不均可能导致热点。
- **`ConcurrentHashMap` JDK 1.8+ (CAS + `synchronized` + Node)**:
    
    - 放弃分段锁，采用数组+链表/红黑树结构。锁粒度降低到哈希桶头节点。
    - **`put`操作**:
        - 若桶为空，用**CAS**尝试设置头节点。
        - 若桶不为空，对头节点加`synchronized`锁后操作。
    - **`size`操作**: 引入`baseCount`和`CounterCell[]`数组并发维护，分散计数。

---

## 线程池扩容，线程池拒绝策略

**线程池工作及扩容流程**:

1. 若当前运行线程数 < **核心线程数 (`corePoolSize`)**，创建新核心线程执行任务。
2. 否则，若**工作队列 (`workQueue`)** 未满，任务入队。
3. 否则，若当前运行线程数 < **最大线程数 (`maximumPoolSize`)**，创建新非核心线程执行任务。
4. 否则，触发**拒绝策略 (`RejectedExecutionHandler`)**。

**线程池的拒绝策略**:

1. **`AbortPolicy` (默认)**: 抛出`RejectedExecutionException`。
2. **`CallerRunsPolicy`**: 任务回退到调用`execute`的线程中执行。
3. **`DiscardPolicy`**: 直接丢弃任务。
4. **`DiscardOldestPolicy`**: 丢弃队列中最旧的任务，然后重试当前任务。
5. **自定义策略**: 实现`RejectedExecutionHandler`接口。

---

## volatile

`volatile`保证：

1. **可见性:
    - 修改`volatile`变量时，JMM将线程本地内存副本刷新到主内存。
    - 读取`volatile`变量时，JMM使线程本地内存副本失效，从主内存重读。
2. **有序性 :
    - 通过插入内存屏障禁止指令重排序优化。
    - **写操作屏障**: `StoreStore` (前), `StoreLoad` (后)。
    - **读操作屏障**: `LoadLoad` (后), `LoadStore` (后)。

`volatile`**不保证原子性** (e.g., `count++`操作非原子)。

---

## synchronized升级过程

锁升级是单向的：偏向锁 → 轻量级锁 → 重量级锁。

1. **偏向锁 :
    - 优化单线程执行同步块场景。对象头记录线程ID，后续进入退出无CAS。
    - 若有其他线程竞争，升级为轻量级锁。
2. **轻量级锁**:
    - 优化多线程交替执行、少竞争场景。
    - 线程栈帧中建锁记录，CAS更新对象头指向锁记录。
    - HotSpot中，若CAS失败，**直接升级为重量级锁**。
3. **重量级锁 :
    - 处理多线程激烈竞争。对象头指向操作系统互斥量。
    - **自适应自旋**: 阻塞前尝试忙等待。
    - 若自旋失败，线程阻塞。

---

## UPDATE指令是不是原子性的

是的，数据库层面的单条`UPDATE`指令在事务上下文中通常被认为是**原子性的**。 这通过以下机制保证：

1. **事务 : `UPDATE`在事务中执行，具备ACID特性。
2. **锁机制 : 对涉及的行加**行级锁**等，防止并发干扰。
3. **日志 :
    - **Undo Log**: 记录修改前的数据，用于失败时回滚。
    - **WAL (Write-Ahead Logging)**: 确保日志先于数据写入磁盘，保证可恢复性。

---

## 联合索引abc，查询`WHERE a = ? AND b > ? AND c = ?`，能用到哪些字段

对于在字段`(a, b, c)`上创建的联合索引，查询条件为 `WHERE a = ? AND b > ? AND c = ?`：

- **字段 `a`**: 可以被高效利用。索引会首先根据`a`的等值条件进行精确定位。
- **字段 `b`**: 也可以被利用。在确定了`a`的范围后，索引会接着根据`b > ?`的范围条件进行扫描。
- **字段 `c`**: **通常不能有效利用索引进行精确的等值匹配或范围扫描后的进一步筛选**。因为一旦索引列出现范围查询（如`b > ?`），该范围查询列（`b`）及其后续的索引列（`c`）的有序性对于精确匹配就可能失效了。数据库通常会扫描所有满足`a = ? AND b > ?`条件的索引条目，然后对于这些条目再单独检查`c = ?`的条件（这部分通常是Filter操作，而不是索引定位）。

**总结**: 能用到索引的字段是 **`a`** 和 **`b`**。